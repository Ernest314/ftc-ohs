#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S2,     infrared,      sensorI2CCustom)
#pragma config(Sensor, S3,     sensor_3,       sensorNone)
#pragma config(Sensor, S4,     sensor_4,       sensorNone)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     motor_L,       tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motor_R,       tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motor_lift,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motor_G,       tmotorTetrix, openLoop)
// Code generated by 'ROBOTC' configuration wizard
#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "../Header Files/IR-driver.h"
#include "../Header Files/enums-6121.h"
#include "../Header Files/global vars-6121.h"
#include "../Header Files/low-level functions-6121.h"
#include "../Header Files/high-level functions-6121.h"
#include "../Header Files/subroutines-6121.h"



void initializeRobot()
{
	// Sensors are config'ed and setup by RobotC (need to stabalize).
	return;
}



task main()
{
	// These will be used every loop, and are declared
	// here to save from declaring them every loop.
	int powerL = 0;
	int powerR = 0;

	waitForStart();
	initializeRobot();



	// At "max capacity", each loop should do 8 checks and
	// 3 assignments: 2 x (2 joysticks + buttons + 1 D-pad).
	// The order is:
		// (D-pad)
		// Joysticks
		// Buttons

	// Default arguments are never passed if not needed (to optimize).

	// Using a `for` loop (instead of `while`) is more intuitive,
	// flexible, and makes code more readable (e.g. for indexing).

	for (int i=0; ; i++)	// `int i` is used in many included headers.
	{
		Joystick_UpdateData();

		// These should be zeroed after every loop, so if there
		// isn't any input, the motors will have no power.
		powerL = 0;
		powerR = 0;
		powerLift = 0;



	// CONTROLLER 2 INPUT:==================================================||>

		// JOYSTICKS INPUT:--------------------------------------------------|>
		// Input from the two joysticks will control the lift at
		// different speeds (fast for R, slow for L). These will
		// not override the input from the primary driver.
			// This is because the input from the primary driver is
			// processed last, therefore getting "the last say".

		// The signals are only processed if it is above a threshold.
		if ( abs(Joystick_Joystick(JOYSTICK_L, AXIS_Y, CONTROLLER_2))
					>g_JoystickThreshold )
		{
			isLiftState = LIFT_JOYSTICK;
			powerLift =
				Math_ToLogarithmic
					(Joystick_Joystick(JOYSTICK_L, AXIS_Y, CONTROLLER_2));
		}
		if ( abs(Joystick_Joystick(JOYSTICK_R, AXIS_Y, CONTROLLER_2))
					>g_JoystickThreshold )
		{
			isLiftState = LIFT_JOYSTICK;
			powerLift =
				Math_ToLogarithmic
					(Joystick_Joystick(JOYSTICK_R, AXIS_Y, CONTROLLER_2)
						/g_SlowLiftFactor);
		}



	// CONTROLLER 1 INPUT:==================================================||>

		// D-PAD INPUT:--------------------------------------------------|>
		// Only if D-pad is pressed, test for direction.

		// Controls lift and has two unimplemented functions
		// for taking rings off/putting rings on.
		if ( Joystick_Direction() != DIRECTION_NONE )
		{
			switch ( Joystick_Direction() )
			{

				// Operate lift at full power if F/B.
				case DIRECTION_F:
					isLiftState = LIFT_JOYSTICK;
					powerLift = g_FullLiftPower/g_SlowLiftFactor;
					break;
				case DIRECTION_B:
					isLiftState = LIFT_JOYSTICK;
					powerLift = (-1)*g_FullLiftPower/g_SlowLiftFactor;
					break;

				case DIRECTION_L:

					break;
				case DIRECTION_R:

					break;
			}
		}


		// JOYSTICKS INPUT:--------------------------------------------------|>
		// Controls most of the driving. We are using two separate
		// checks, because combining them into one check will execute
		// both even if only one joystick is pressed. The linking of
		// both checks (disjunction) checks both inputs anyways.

		// The signals are only processed if it is above a threshold.
		if ( abs(Joystick_Joystick(JOYSTICK_L, AXIS_Y)) > g_JoystickThreshold )
		{
			powerL = Math_ToLogarithmic(Joystick_Joystick(JOYSTICK_L, AXIS_Y));
		}
		if ( abs(Joystick_Joystick(JOYSTICK_R, AXIS_Y)) > g_JoystickThreshold )
		{
			powerR = Math_ToLogarithmic(Joystick_Joystick(JOYSTICK_R, AXIS_Y));
		}


		// BUTTONS INPUT:--------------------------------------------------|>
		// Everything other than the buttons used might be masked to
		// (possibly) increase speed.
		// Reasoning: `&` compares every bit, so we might as well mask,
		// in case something irrelevant is pressed.

		// A `0` value means no buttons (that we test for) are pressed.
		// Directly using the struct since this is the only time we
		// use it, and the code is meant to be low-level anyways.

		// Uncomment the next line and comment the one after if masking.
			// For an explanation of masking the buttons' input,
			// see the comments accompanying CONTROLLER_1's buttons.
		//if ( (g_ControllerMaskA & joystick.joy1_Buttons) != false )
		if ( joystick.joy1_Buttons != false )
		{
			// Buttons Y/B/A/X will control lift height.
			if ( Joystick_Button(BUTTON_Y)==true )
			{
				isLiftState = LIFT_TOP;
			}
			if ( Joystick_Button(BUTTON_B)==true )
			{
				isLiftState = LIFT_MIDDLE;
			}
			if ( Joystick_Button(BUTTON_A)==true )
			{
				isLiftState = LIFT_BOTTOM;
			}
			if ( Joystick_Button(BUTTON_X)==true )
			{
				isLiftState = LIFT_FETCH;
			}

			// Buttons LT/RT fine-tune the lift.
			if ( Joystick_Button(BUTTON_RT)==true )
			{
				isLiftState = LIFT_JOYSTICK;
				powerLift = g_FullLiftPower;
			}
			if ( Joystick_Button(BUTTON_LT)==true )
			{
				isLiftState = LIFT_JOYSTICK;
				powerLift = (-1)*g_FullLiftPower;
			}

			// If LB/RB is pressed, fine-tune the motors.
			if ( (Joystick_Button(BUTTON_LB)||
					Joystick_Button(BUTTON_RB)) ==true )
			{
				powerL /= g_SlowDriveFactor;
				powerR /= g_SlowDriveFactor;
			}
		}
		if(Joystick_Button(BUTTON_RB) == true)
		{
			powerL /= g_FineTuneFactor;
			powerR /= g_FineTuneFactor;
	  }

	  if (Joystick_Button(BUTTON_RT) == true)
		{
			liftPower /= g_FineTuneFactor;
		}
		if(Joystick_Button(BUTTON_LT) == true)
		{
			liftPower /= g_FineTuneFactor;
	  }



	// FINAL PROCESSING:==================================================||>

		// After preliminary processing of the controller data,
		// the actual motor/servo assignments happen here.

		switch (isLiftState)
		{
			case LIFT_BOTTOM:
				sub_LiftToHeight(g_BottomLiftAngle);
				break;
			case LIFT_MIDDLE:
			  	sub_LiftToHeight(g_MiddleLiftAngle);
				break;
			case LIFT_TOP:
			    sub_LiftToHeight(g_TopLiftAngle);
				break;
			case LIFT_FETCH:
			 	sub_LiftToHeight(g_FetchLiftAngle);
			    break;
		}

		Motor_SetPower(motor_L, powerL);
		Motor_SetPower(motor_R, powerR);
		Motor_SetPower(motor_lift, powerLift);
	}
}








//-------------------------Your original code is as follows:
//// Reconcile the joystick scale of 0 to 128
//// with the Motor scale of 0 to 100
//int scaleForMotor(int joyValue)
//{
//	// Note that the Motor can take a max value of 100
//  // But we're playing it safe and staying at 80 only
//	const int MAX_MOTOR_VAL = 80;

//	// The joystick value is +127 to -128
//	const float MAX_JOY_VAL = 128;

//	const int DEADZONE = 15;

//	if (abs(joyValue) < DEADZONE)
//		return 0;

//	int direction = joyValue / abs(joyValue);
//	float ratio = ( (joyValue * joyValue) / (MAX_JOY_VAL * MAX_JOY_VAL) );
//	int scaledVal = (ratio * MAX_MOTOR_VAL) * direction;

//	return scaledVal;
//}


//task main()
//{
//	// CATH: Make sure you choose "Joystick Control - Competition"
//  // This is in (Robot)->(Debugger Windows)->
//	waitForStart();

//	int powerL = 0;
//	int powerR = 0;
//	int liftPower = 0;

//	while (true)
//	{
//		Joystick_UpdateData();

//		// These should be zeroed after every loop. In the case that there
//		// isn't input, the robot won't keep moving at the last speed it had.
//		powerL = 0;
//		powerR = 0;

//		//Put something in the NXT LCD screen (just for grins)
//		nxtDisplayTextLine(2, "Catherine Program");

//		/*
//		// Y-axis code:
//		if ( 	abs(joystick.joy1_y1) > g_JoystickThreshold ||
//				abs(joystick.joy1_y2) > g_JoystickThreshold )
//		{
//			powerL = joystick.joy1_y1;
//			powerR = joystick.joy1_y2;
//		}

//		// Last check: if LB/RB is pressed, fine-tune the power level.
//		if ( (Joystick_Button(BUTTON_LB)||Joystick_Button(BUTTON_RB)) ==true )
//		{
//			powerL /= g_FineTuneFactor;
//			powerR /= g_FineTuneFactor;
//		}
//		if (Joystick_Button(BUTTON_X)) {
//			liftPower = 75;
//		}
//		else if (Joystick_Button(BUTTON_A)) {
//			liftPower = -75;
//		}
//		else {
//			liftPower = 0;
//		}
//		if (Joystick_Button(BUTTON_LT)) {
//			liftPower *= 2;
//		}
//		*/

//		/*
//		//CATH: New code
//		//Control the FrontL and FrontR motors using the LT,RT,LB,RB buttons
//		//LB & RB to go forward
//		//LT & RT to go backward
//		//*
//		powerL = powerR = 0;
//		if (Joystick_Button(BUTTON_LT)) {
//			powerL = 80;
//		}
//		if (Joystick_Button(BUTTON_RT)) {
//			powerR = 80;
//		}
//			if (Joystick_Button(BUTTON_LB)) {
//			powerL = -80;
//		}
//		if (Joystick_Button(BUTTON_RB)) {
//			powerR = -80;
//		}
//		*/



///*
//		//CATH: New code
//		//Control the FrontL and FrontR motors using the Top Hat
//		powerL = powerR = 0;
//		if(joystick.joy1_TopHat == 0) {
//  		powerL = powerR = -50; //forward
//  		nxtDisplayTextLine(0, "forward");
//		} else if(joystick.joy1_TopHat == 4) {
//			powerL = powerR = 50; //reverse
//  		nxtDisplayTextLine(0, "reverse");
//  	} else if(joystick.joy1_TopHat == 6) {
//  		powerL =  50; //backward
//  		powerR = -50; //forward
//  		nxtDisplayTextLine(0, "left turn");
//  	} else if(joystick.joy1_TopHat == 2) {
//  	  powerL = -50; //forward
//  		powerR =  50; //backward
//  		nxtDisplayTextLine(0, "right turn");
//		} else {
//  		powerL = powerR = 0; //off
//  		nxtDisplayTextLine(0, "stop");
//		}
//*/


//		//CATH: New code
//		//Control the left and right motors using the joysticks.
//		//One joystick for the left; the other for the right.
//    powerL = -1 * scaleForMotor(joystick.joy1_y1); //David: erm only this one needs to be negative now because we switched up some wires. (Not actually sure what should be negative and what positive, we can find out Sunday)
//    powerR = scaleForMotor(joystick.joy1_y2);

//     //raise or lower the lift (or do neither)
//		if (Joystick_Button(BUTTON_Y)) {
//			liftPower = 80;
//		}
//		else if (Joystick_Button(BUTTON_A)) {
//			liftPower = -80;
//		}
//		else{
//			liftPower = 0;
//		}

//        // Last check: if LB/RB is pressed, fine-tune the power level.
//		if ( (Joystick_Button(BUTTON_LB)||Joystick_Button(BUTTON_RB)) ==true )
//		{
//			powerL /= g_FineTuneFactor;
//			powerR /= g_FineTuneFactor;
//		}

//    nxtDisplayTextLine(3, "Left  is %d", powerL);
//    nxtDisplayTextLine(4, "Right is %d", powerR);


//		//TODO: Logarithmic thingy for the joysticks.
//		// Set the power level of the left and right motors.
//		Motor_SetPower(motorR, powerR);
//		Motor_SetPower(motorL, powerL);

//		// Raise the lift
//		//TODO: Experiment with limiting the amount the motor can go/down.
//		Motor_SetPower(motorLiftL, liftPower);
//		Motor_SetPower(motorLiftR, liftPower);

//	}
//}
